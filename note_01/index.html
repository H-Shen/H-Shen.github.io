<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Haohu Shen's ePortfolio</title><meta name="author" content="Haohu Shen"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Haohu Shen's ePortfolio" type="application/atom+xml">
</head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Haohu Shen's ePortfolio</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/about"> About</a></li><li class="menus_item"><a class="site-page" href="/blogs"> Blogs</a></li><li class="menus_item"><a class="site-page" href="/projects"> Projects</a></li><li class="menus_item"><a class="site-page" href="/notes"> Notes</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/profile.png'" alt="avatar"></div><div class="author-discrip"><h3>Haohu Shen</h3><p class="author-bio">Premature optimization is the root of all evil.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="https://github.com/H-Shen" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="https://stackoverflow.com/users/6844098/haohu-shen" target="_blank"><i class="fab fa-stack-overflow" aria-hidden="true"></i></a></li><li><a class="social-icon" href="https://www.linkedin.com/notifications/?filter=all" target="_blank"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="social-icon" href="mailto:haohu3991@gmail.com" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title"></h2><article><h4 id="Usage-of-New-Features-in-C-17-20"><a href="#Usage-of-New-Features-in-C-17-20" class="headerlink" title="Usage of New Features in C++17&#x2F;20"></a>Usage of New Features in C++17&#x2F;20</h4><h5 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional<T></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">optional&lt;<span class="type">int</span>&gt; <span class="title">getSquare</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    optional&lt;<span class="type">int</span>&gt; result;   <span class="comment">// the status is invalid after initialization</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//The status becomes valid after the assignment</span></span><br><span class="line">        result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">sqrt</span>(n * <span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">getSquare</span>(<span class="number">-1</span>).<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">getSquare</span>(<span class="number">0</span>).<span class="built_in">has_value</span>());</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getSquare</span>(<span class="number">0</span>).<span class="built_in">value</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// return 999 if it is invalid</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getSquare</span>(<span class="number">-1</span>).<span class="built_in">value_or</span>(<span class="number">999</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">optional&lt;string&gt; <span class="title">s</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(s);</span><br><span class="line">    <span class="built_in">assert</span>(*s == <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    s.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Create an optional object using a factory method</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> op1 = <span class="built_in">make_optional</span>&lt;<span class="type">int</span>&gt;();    <span class="comment">// default constructor</span></span><br><span class="line"><span class="keyword">auto</span> op2 = <span class="built_in">make_optional</span>&lt;string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(op1 &amp;&amp; op2);           <span class="comment">// make_optional is always valid</span></span><br><span class="line"><span class="built_in">assert</span>(op1 == <span class="number">0</span>);             <span class="comment">// default 0</span></span><br><span class="line"><span class="built_in">assert</span>(op2-&gt;<span class="built_in">empty</span>());         <span class="comment">// default empty string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make_optional call argument constructor</span></span><br><span class="line"><span class="keyword">auto</span> op3 = <span class="built_in">make_optional</span>&lt;string&gt;(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> op4 = make_optional&lt;vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(op3-&gt;<span class="built_in">size</span>() == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(op4-&gt;<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>When the internal type of an optional<T> object is bool, it should be judged twice. First, determine whether the state of the container is valid, and then, if the container is valid, determine the value.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optional&lt;<span class="type">bool</span>&gt; op &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (op) &#123;               </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;misuse&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op &amp;&amp; op.<span class="built_in">value</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; right &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="variant-替代-union"><a href="#variant-替代-union" class="headerlink" title="variant&lt;多个互不相同的类型&gt; 替代 union"></a>variant&lt;多个互不相同的类型&gt; 替代 union</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">variant&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; v;       <span class="comment">// 可以容纳三种不同的整数</span></span><br><span class="line"></span><br><span class="line">v = <span class="number">42</span>;                 <span class="comment">// 直接赋值为int</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">index</span>() == <span class="number">0</span>);         <span class="comment">// 索引号是0</span></span><br><span class="line"></span><br><span class="line">v = <span class="number">3.14f</span>;                 <span class="comment">// 直接赋值为float</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">index</span>() == <span class="number">1</span>);         <span class="comment">// 索引号是1</span></span><br><span class="line"></span><br><span class="line">v = <span class="number">2.718</span>;                 <span class="comment">// 直接赋值为double</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">index</span>() == <span class="number">2</span>);         <span class="comment">// 索引号是2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v = <span class="number">42</span>;               <span class="comment">// 赋值为int</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(v) == <span class="number">42</span>);       <span class="comment">// 取第0号的值，即int</span></span><br><span class="line"></span><br><span class="line">v = <span class="number">2.718</span>;               <span class="comment">// 赋值为double</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(v);       <span class="comment">// 取double的值，即第2号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v);             <span class="comment">// 当前是double，所以出错，抛出std::bad_variant_access异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用get_if代替get 传地址 返回一个对应类型的指针 如果不存在则返回nullptr</span></span><br><span class="line"><span class="type">int</span>* p1 = <span class="built_in">get_if</span>&lt;<span class="type">int</span>&gt;(&amp;v);</span><br><span class="line"><span class="built_in">assert</span>(p1 == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">double</span>* p2 = <span class="built_in">get_if</span>&lt;<span class="type">double</span>&gt;(&amp;v);</span><br><span class="line"><span class="built_in">assert</span>(*p2 == <span class="number">2.718</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用visit和visitor函数访问variant容器当前有效值 不需要知道具体类型 visitor函数必须是一个支持泛型的lambda函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>&gt; v;</span><br><span class="line">v = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> visitor = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">    cout &lt;&lt; v+v &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> changer = [](<span class="keyword">auto</span>&amp; val) &#123;</span><br><span class="line">  val += val;</span><br><span class="line">&#125;;</span><br><span class="line">std::<span class="built_in">visit</span>(visitor, v);</span><br><span class="line">std::<span class="built_in">visit</span>(changer, v);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v) == <span class="number">24</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>variant的作用: 在不使用“继承”“虚函数”的情况下实现面向对象编程里的“多态”特性</li>
</ul>
<h4 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h4><ul>
<li>核心思想是“类型运算”，操作的数据是编译时可见的“类型”</li>
</ul>
<h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><ul>
<li>核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码</li>
</ul>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><ul>
<li>数学意义上、无副作用的函数，核心思想是“一切皆可调用”，通过一系列连续或者嵌套的函数调用实现对数据的处理</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><ul>
<li><p>m_ 前缀修饰成员变量</p>
</li>
<li><p>g_ 前缀修饰全局变量</p>
</li>
<li><p>C 和 C++ 主要采用的命名方式是 snaking naming convention</p>
<ul>
<li>变量、函数名和<strong>名字空间</strong>用 snake_case，全局变量加“g_”前缀；</li>
<li>自定义类名用 CamelCase，成员函数用 snake_case，成员变量加“m_”前缀；</li>
<li>宏和常量应当全大写，单词之间用下划线连接；</li>
<li>尽量不要用下划线作为变量的前缀或者后缀（比如 _local、name_），很难识别</li>
</ul>
</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// author  : chrono</span></span><br><span class="line"><span class="comment">// date    : 2020-xx-xx</span></span><br><span class="line"><span class="comment">// purpose : get the inner counter value of generic T</span></span><br><span class="line"><span class="comment">// notice  : T must have xxx member</span></span><br><span class="line"><span class="comment">// notice  : return value maybe -1, means xxx, you should xxx</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">(<span class="type">const</span> T&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件头注释</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Copyright (c) 2020 by Chrono</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// file  : xxx.cpp</span></span><br><span class="line"><span class="comment">// since : 2020-xx-xx</span></span><br><span class="line"><span class="comment">// desc  : ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以用cpplint静态检查cpp代码风格</p>
</li>
<li><p>尽量使用include guard 少用 #pragma once</p>
</li>
<li><p>只输出预处理后的源码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++<span class="number">14</span> -Wall -O2 -E a.cpp -o a.cc  </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.txt&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>#define 宏全局替换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_tolower(c)      ((c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ? (c | 0x20) : c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_toupper(c)      ((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ? (c &amp; ~0x20) : c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>#define 宏定义命名空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE(x)  namespace x &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE(x)    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_NAMESPACE</span>(my_own)</span><br><span class="line"></span><br><span class="line"><span class="comment">// functions and classes here</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">END_NAMESPACE</span>(my_own)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 定义了这个宏就是在用C++编译</span></span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;                        <span class="comment">// 函数按照C的方式去处理 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a_c_function</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 检查是否是C++编译</span></span></span><br><span class="line">    &#125;                                   <span class="comment">// extern &quot;C&quot; 结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201402                <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++14 or later&quot;</span> &lt;&lt; endl;    <span class="comment">// 201402就是C++14</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __cplusplus &gt;= 201103              <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++11 or before&quot;</span> &lt;&lt; endl;   <span class="comment">// 201103是C++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __cplusplus &lt; 201103          // 199711是C++98</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;c++ is too old&quot;</span>               <span class="comment">// 太低则预处理报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __cplusplus &gt;= 201402         // 预处理语句结束</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E -dM - &lt; /dev/null <span class="comment"># gcc查询编译器自带宏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_decltype_auto        <span class="comment">//检查是否支持decltype(auto)</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) enable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) disable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//__cpp_decltype_auto</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &lt;= 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is too old&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __GNUC__ &gt; 4</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is good enough&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __GNUC__ &lt;= 4</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;we can do more optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="使用-if-1-和-if-0-启用和禁用大段代码"><a href="#使用-if-1-和-if-0-启用和禁用大段代码" class="headerlink" title="使用#if 1 和#if 0 启用和禁用大段代码"></a>使用#if 1 和#if 0 启用和禁用大段代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0          <span class="comment">// 0即禁用下面的代码，1则是启用</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1          <span class="comment">// 1启用代码，用来强调下面代码的必要性</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br></pre></td></tr></table></figure>

<h5 id="C-17-has-include-检测文件是否存在"><a href="#C-17-has-include-检测文件是否存在" class="headerlink" title="C++17 __has_include 检测文件是否存在"></a>C++17 __has_include 检测文件是否存在</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&quot;example.h&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;cannot find example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="函数模版显式全特化"><a href="#函数模版显式全特化" class="headerlink" title="函数模版显式全特化"></a>函数模版显式全特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int32_t</span> <span class="built_in">f</span>&lt;<span class="type">int32_t</span>,<span class="type">int8_t</span>&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译属性"><a href="#编译属性" class="headerlink" title="编译属性"></a>编译属性</h4><ul>
<li>给变量、函数、类等“贴”上一个编译阶段的“标签”，方便编译器识别处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]]              <span class="comment">// 属性标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> flag)</span>       <span class="comment">// 函数绝不会返回任何值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;deadline:2020-12-31&quot;</span>)]]      <span class="comment">// 函数被废除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) [[likely]]   <span class="comment">// 告诉编译器这条分支执行成功的可能性大</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">pow</span>(x, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      [[fallthrough]]   <span class="comment">// 告诉编译器这个case没有break 直接往下走</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      [[fallthrough]]</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用官方属性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]]</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;&quot;</span>)]]</span><br><span class="line">[[deprecated]]</span><br><span class="line">[[fallthrough]]</span><br><span class="line">[[nodiscard]]</span><br><span class="line">[[<span class="built_in">nodiscard</span>(<span class="string">&quot;&quot;</span>)]]</span><br><span class="line">[[maybe_unused]]</span><br><span class="line">[[likely]]</span><br><span class="line">[[unlikely]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用gnu属性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::constructor]] <span class="comment">// 函数会在 main() 函数之前执行，效果有点像是全局对象的构造函数</span></span><br><span class="line">[[gnu::destructor]] <span class="comment">// 函数会在 main() 函数结束之后执行，有点像是全局对象的析构函数</span></span><br><span class="line">[[gnu::always_inline]] <span class="comment">// 强制内联</span></span><br><span class="line">[[gnu::hot]] <span class="comment">// 热点函数，要求编译器更积极地优化</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::<span class="built_in">constructor</span>(<span class="number">105</span>)]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">[[gnu::<span class="built_in">constructor</span>(<span class="number">106</span>)]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[gnu::<span class="built_in">destructor</span>(<span class="number">106</span>)]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">[[gnu::<span class="built_in">destructor</span>(<span class="number">107</span>)]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 ... 4 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行期断言带错误消息的惯用法 如果assert内的condition为false 则会调用abort()</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">assert</span>(i &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;i must be greater than zero&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用编译器指令 <strong>attribute</strong> 可以将属性用在C中</li>
<li>如果编译的时候定义宏NDEBUG 则运行期断言assert会被禁用</li>
<li>不要在类内部定义一些嵌套类 应该定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="keyword">final</span>    <span class="comment">// 禁止任何人继承我</span></span><br><span class="line">&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在必须使用继承的场合，建议你只使用 public 继承，避免使用 virtual、protected，因为它们会让父类与子类的关系变得难以捉摸</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span>        <span class="comment">// 接口类定义，没有final，可以被继承</span></span><br><span class="line">&#123; ... &#125;;           </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implement</span> <span class="keyword">final</span> : <span class="comment">// 实现类，final禁止再被继承</span></span><br><span class="line">      <span class="keyword">public</span> Interface    <span class="comment">// 只用public继承</span></span><br><span class="line">&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="keyword">final</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DemoClass</span>() = <span class="keyword">default</span>;  <span class="comment">// 明确告诉编译器，使用默认实现</span></span><br><span class="line">   ~<span class="built_in">DemoClass</span>() = <span class="keyword">default</span>;  <span class="comment">// 明确告诉编译器，使用默认实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数调用其他构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoDelegating</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;                              <span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DemoDelegating</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x)        <span class="comment">// 基本的构造函数</span></span><br><span class="line">    &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">DemoDelegating</span>() :                 <span class="comment">// 无参数的构造函数</span></span><br><span class="line">        <span class="built_in">DemoDelegating</span>(<span class="number">0</span>)               <span class="comment">// 给出默认值，委托给第一个构造函数</span></span><br><span class="line">    &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">DemoDelegating</span>(<span class="type">const</span> string&amp; s) : <span class="comment">// 字符串参数构造函数</span></span><br><span class="line">        <span class="built_in">DemoDelegating</span>(<span class="built_in">stoi</span>(s))        <span class="comment">// 转换成整数，再委托给第一个构造函数</span></span><br><span class="line">    &#123;&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在声明类成员的时候初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoInit</span> <span class="keyword">final</span>                  <span class="comment">// 有很多成员变量的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>                 a = <span class="number">0</span>;        <span class="comment">// 整数成员，赋值初始化</span></span><br><span class="line">    std::string              s = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 字符串成员，赋值初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;         v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// 容器成员，使用花括号的初始化列表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DemoInit</span>() = <span class="keyword">default</span>;             <span class="comment">// 默认构造函数</span></span><br><span class="line">    ~<span class="built_in">DemoInit</span>() = <span class="keyword">default</span>;             <span class="comment">// 默认析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DemoInit</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123;&#125;         <span class="comment">// 可以单独初始化成员，其他用默认值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>传统的类编写方式是.h .cpp将接口和实现分离 但现代C++多采用hpp方式将接口和实现合并 <strong>因为单独的头文件没法使用类模版</strong></p>
</li>
<li><p>重写接口时 应显式写override</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceAImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> Interface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;          <span class="comment">// 整型变量</span></span><br><span class="line"><span class="keyword">decltype</span>(x)     x1;      <span class="comment">// 推导为int，x1是int</span></span><br><span class="line"><span class="keyword">decltype</span>(x)&amp;    x2 = x;    <span class="comment">// 推导为int，x2是int&amp;，引用必须赋值</span></span><br><span class="line"><span class="keyword">decltype</span>(x)*    x3;      <span class="comment">// 推导为int，x3是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)    x4;      <span class="comment">// 推导为int*，x4是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)*   x5;      <span class="comment">// 推导为int*，x5是int**</span></span><br><span class="line"><span class="keyword">decltype</span>(x2)    x6 = x2;  <span class="comment">// 推导为int&amp;，x6是int&amp;，引用必须赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用decltype获取函数的指针类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>, <span class="type">int</span>, <span class="type">double</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">void</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">double</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func_ptr</span>(<span class="number">12</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="keyword">decltype</span>(&amp;func3) ptr)</span> </span>&#123;    <span class="comment">// 用decltype直接获取func3的类型指针</span></span><br><span class="line">    <span class="built_in">ptr</span>(<span class="number">12</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量避免static成员变量使用auto</p>
</li>
<li><pre><code class="cpp">// str会被推导为std::string
auto str = &quot;abcd&quot;s;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* const定义的变量属于只读变量 不属于常量 它的值可以通过指针修改</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  </span><br><span class="line">  // 需要加上volatile修饰，运行时才能看到效果   如果是在C中 则不需要volatile</span><br><span class="line">  const volatile int MAX_LEN  = 1024;</span><br><span class="line">  auto ptr = (int*)(&amp;MAX_LEN);</span><br><span class="line">  *ptr = 2048;</span><br><span class="line">  cout &lt;&lt; MAX_LEN &lt;&lt; endl;      // 输出2048</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>const &amp; 被称为万能引用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 放在声明的最左边，表示指向常量的指针</span></span><br><span class="line">string name = <span class="string">&quot;uncharted&quot;</span>;</span><br><span class="line"><span class="type">const</span> string* ps1 = &amp;name; <span class="comment">// 指向常量</span></span><br><span class="line">*ps1 = <span class="string">&quot;spiderman&quot;</span>;        <span class="comment">// 错误，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 放在*右边 表示指针式常量 不能再指向其他对象</span></span><br><span class="line">string* <span class="type">const</span> ps2 = &amp;name;  <span class="comment">// 指向变量，但指针本身不能被修改</span></span><br><span class="line">*ps2 = <span class="string">&quot;spiderman&quot;</span>;        <span class="comment">// 正确，允许修改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>unique_ptr 对资源只有一份ownership</li>
<li>shared_ptr 对资源可以有多个ownership 原理是引用计数</li>
<li>weak_ptr 用来修复shared ptr导致的循环引用问题</li>
<li>尽量使用工厂函数初始化智能指针 避免空指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;      <span class="comment">// int智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr1 == <span class="number">10</span>);                     <span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="built_in">assert</span>(ptr1 != <span class="literal">nullptr</span>);                <span class="comment">// 可以判断是否为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;  <span class="comment">// string智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr2 == <span class="string">&quot;hello&quot;</span>);                <span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="built_in">assert</span>(ptr2-&gt;<span class="built_in">size</span>() == <span class="number">5</span>);               <span class="comment">// 可以使用-&gt;调用成员函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr3 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);               <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr4 = <span class="built_in">make_unique</span>&lt;string&gt;(<span class="string">&quot;god of war&quot;</span>);  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr4-&gt;<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引发循环引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> this_type     = Node;</span><br><span class="line">    <span class="keyword">using</span> shared_type   = std::shared_ptr&lt;this_type&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_type     next;      <span class="comment">// 使用智能指针来指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n1 = <span class="built_in">make_shared</span>&lt;Node&gt;();   <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="built_in">make_shared</span>&lt;Node&gt;();   <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(n1.<span class="built_in">use_count</span>() == <span class="number">1</span>);    <span class="comment">// 引用计数为1</span></span><br><span class="line"><span class="built_in">assert</span>(n2.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">n1-&gt;next = n2;                 <span class="comment">// 两个节点互指，形成了循环引用</span></span><br><span class="line">n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(n1.<span class="built_in">use_count</span>() == <span class="number">2</span>);    <span class="comment">// 引用计数为2</span></span><br><span class="line"><span class="built_in">assert</span>(n2.<span class="built_in">use_count</span>() == <span class="number">2</span>);    <span class="comment">// 无法减到0，无法销毁，导致内存泄漏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用weak ptr修改上例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> this_type     = Node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，别名改用weak_ptr</span></span><br><span class="line">    <span class="keyword">using</span> shared_type   = std::weak_ptr&lt;this_type&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_type     next;    <span class="comment">// 因为用了别名，所以代码不需要改动</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n1 = <span class="built_in">make_shared</span>&lt;Node&gt;();  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="built_in">make_shared</span>&lt;Node&gt;();  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"></span><br><span class="line">n1-&gt;next = n2;             <span class="comment">// 两个节点互指，形成了循环引用</span></span><br><span class="line">n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(n1.<span class="built_in">use_count</span>() == <span class="number">1</span>);    <span class="comment">// 因为使用了weak_ptr，引用计数为1</span></span><br><span class="line"><span class="built_in">assert</span>(n2.<span class="built_in">use_count</span>() == <span class="number">1</span>);   <span class="comment">// 打破循环引用，不会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!n1-&gt;next.<span class="built_in">expired</span>()) &#123;     <span class="comment">// 检查指针是否有效</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = n1-&gt;next.<span class="built_in">lock</span>();  <span class="comment">// lock()获取shared_ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(ptr == n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常的好处<ul>
<li>处理流程是完全独立的</li>
<li>绝对不能被忽略的，必须被处理</li>
<li>可以用在错误码无法使用的场合</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己封装一个runtime error异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">final</span> : <span class="keyword">public</span> std::runtime_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> this_type = MyException;</span><br><span class="line">    <span class="keyword">using</span> base_type = std::runtime_error;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">MyException</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyException</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> : base_type(message) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> code = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在抛出异常的时候，我建议你最好不要直接用 throw 关键字，而是要封装成一个函数，这和不要直接用 new、delete 关键字而是使用智能指针是类似的道理——通过引入一个“中间层”来获得更多的可读性、安全性和灵活性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">raise</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>      <span class="comment">// 函数封装throw，没有返回值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">my_exception</span>(msg);     <span class="comment">// 抛出异常，也可以有更多的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>function-try块</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">some_function</span><span class="params">(<span class="type">int</span> n = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span>                          <span class="comment">// 函数名之后直接写try块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">throw</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)                   <span class="comment">// catch块与函数体同级并列</span></span><br><span class="line">&#123;</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>noexcept 告诉编译器：这个函数不会抛出异常 实际上是告诉编译器不要做优化 如果遇到异常 直接调用 std::terminate 终止运行。为了优化性能 避免异常产生出现的栈展开 重要的ctor dtor应该尽量声明为 noexcept</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_noexcept</span><span class="params">()</span> <span class="keyword">noexcept</span>            <span class="comment">// 声明绝不会抛出异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;noexcept&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归lambda</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    func = [&amp;](<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*<span class="built_in">func</span>(n<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>[&#x3D;]表示lambda按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改 需要修改则要增加 mutable 注意此时修改的是变量的拷贝</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]()&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    n += <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line">cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类内使用lambda [*this]表示拷贝当前对象 [this]表示引用当前对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_val = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; print_val = [*<span class="keyword">this</span>]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">        m_val = <span class="number">15</span>;</span><br><span class="line">        cout &lt;&lt; m_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::function&lt;<span class="type">int</span>()&gt; getVal = [*<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="keyword">return</span> m_val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> <span class="type">int</span>&amp;)&gt; setVal = [<span class="keyword">this</span>](<span class="type">const</span> <span class="type">int</span>&amp; val) &#123;</span><br><span class="line">        m_val = val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>std::string 本质是模板类 basic_string 的特化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> string = std::basic_string&lt;<span class="type">char</span>&gt;;</span><br><span class="line"></span><br><span class="line">*   字符串和容器完全是两个不同的概念</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">auto</span> str = <span class="string">&quot;abcd&quot;</span>s; <span class="comment">// 明确地表示它是 string 字符串类型</span></span><br><span class="line"><span class="keyword">auto</span> str = <span class="string">R&quot;(nier:automata)&quot;</span>;    <span class="comment">// 原始字符串：nier:automata 不转义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义一个stringview类</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStringView</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStringView</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">MyStringView</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyStringView</span>(<span class="type">const</span> string&amp;s) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">ptr</span>(s.<span class="built_in">data</span>()), <span class="built_in">len</span>(s.<span class="built_in">length</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>regex_match 完全匹配一个字符串</li>
<li>regex_search 在字符串里查找一个正则匹配</li>
<li>regex_replace 正则查找再做替换</li>
<li>写正则的时候，记得最好要用原始字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> str = <span class="string">&quot;god of war&quot;</span>s;             <span class="comment">// 待匹配的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> reg  = </span><br><span class="line">  <span class="built_in">make_regex</span>(<span class="string">R&quot;((\w+)\s(\w+))&quot;</span>);    <span class="comment">// 原始字符串定义正则表达式</span></span><br><span class="line"><span class="keyword">auto</span> what = <span class="built_in">make_match</span>();          <span class="comment">// 准备获取匹配的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> found = <span class="built_in">regex_search</span>(          <span class="comment">// 正则查找，和匹配类似</span></span><br><span class="line">                str, what, reg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(found);                        <span class="comment">// 断言找到匹配</span></span><br><span class="line"><span class="built_in">assert</span>(!what.<span class="built_in">empty</span>());                <span class="comment">// 断言有匹配结果</span></span><br><span class="line"><span class="built_in">assert</span>(what[<span class="number">1</span>] == <span class="string">&quot;god&quot;</span>);              <span class="comment">// 看第一个子表达式</span></span><br><span class="line"><span class="built_in">assert</span>(what[<span class="number">2</span>] == <span class="string">&quot;of&quot;</span>);              <span class="comment">// 看第二个子表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> new_str = <span class="built_in">regex_replace</span>(      <span class="comment">// 正则替换，返回新字符串</span></span><br><span class="line">    str,                           <span class="comment">// 原字符串不改动</span></span><br><span class="line">    <span class="built_in">make_regex</span>(<span class="string">R&quot;(\w+$)&quot;</span>),         <span class="comment">// 就地生成正则表达式对象</span></span><br><span class="line">    <span class="string">&quot;peace&quot;</span>                        <span class="comment">// 需要指定替换的文字</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; new_str &lt;&lt; endl;          <span class="comment">// 输出god of peace</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试函数运行消耗的时钟周期</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">[[gnu::noinline]]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = __rdtsc();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> end = __rdtsc();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f() spent %llu CPU cycles.\n&quot;</span>, end - start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stl容器里存储的是元素的拷贝、副本，而不是引用</p>
</li>
<li><p>for_each</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> print = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; x)  <span class="comment">// lambda表达式输出元素</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v));         <span class="comment">// 快速排序</span></span><br><span class="line">for_each(<span class="built_in">cbegin</span>(v), <span class="built_in">cend</span>(v), print); <span class="comment">// for_each算法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>partial sort取topK排了序 nth element取topK排了序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// top3</span></span><br><span class="line">std::<span class="built_in">partial_sort</span>(</span><br><span class="line">    <span class="built_in">begin</span>(v), <span class="built_in">next</span>(<span class="built_in">begin</span>(v), <span class="number">3</span>), <span class="built_in">end</span>(v));  <span class="comment">// 取前3名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// best3</span></span><br><span class="line">std::<span class="built_in">nth_element</span>(</span><br><span class="line">    <span class="built_in">begin</span>(v), <span class="built_in">next</span>(<span class="built_in">begin</span>(v), <span class="number">3</span>), <span class="built_in">end</span>(v));  <span class="comment">// 最好的3个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Median</span></span><br><span class="line"><span class="keyword">auto</span> mid_iter =                            <span class="comment">// 中位数的位置</span></span><br><span class="line">    <span class="built_in">next</span>(<span class="built_in">begin</span>(v), v.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">std::<span class="built_in">nth_element</span>( <span class="built_in">begin</span>(v), mid_iter, <span class="built_in">end</span>(v));<span class="comment">// 排序得到中位数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;median is &quot;</span> &lt;&lt; *mid_iter &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// partition</span></span><br><span class="line"><span class="keyword">auto</span> pos = std::<span class="built_in">partition</span>(                <span class="comment">// 找出所有大于9的数</span></span><br><span class="line">    <span class="built_in">begin</span>(v), <span class="built_in">end</span>(v),</span><br><span class="line">    [](<span class="type">const</span> <span class="keyword">auto</span>&amp; x)                    <span class="comment">// 定义一个lambda表达式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line">for_each(<span class="built_in">begin</span>(v), pos, print);         <span class="comment">// 输出分组后的数据  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// min/max</span></span><br><span class="line"><span class="keyword">auto</span> value = std::<span class="built_in">minmax_element</span>(        <span class="comment">//找出第一名和倒数第一</span></span><br><span class="line">    <span class="built_in">cbegin</span>(v), <span class="built_in">cend</span>(v)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>利用std::once_flag和std::call_once, 保证函数在多个线程中只运行一次</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::once_flag flag;        <span class="comment">// 全局的初始化标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = []()                <span class="comment">// 在线程里运行的lambda表达式</span></span><br><span class="line">&#123;   </span><br><span class="line">    std::<span class="built_in">call_once</span>(flag,      <span class="comment">// 仅一次调用，注意要传flag</span></span><br><span class="line">        []()&#123;                <span class="comment">// 匿名lambda，初始化函数，只会执行一次</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;only once&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;                  <span class="comment">// 匿名lambda结束</span></span><br><span class="line">    );                     <span class="comment">// 在线程里运行的lambda表达式结束</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(f)</span></span>;            <span class="comment">// 启动两个线程，运行函数f</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 thread_local 标记的变量在每个线程里都会有一个独立的副本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> n = <span class="number">0</span>;        <span class="comment">// 线程局部存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;](<span class="type">int</span> x)           <span class="comment">// 在线程里运行的lambda表达式，捕获引用</span></span><br><span class="line">&#123;   </span><br><span class="line">    n += x;                   <span class="comment">// 使用线程局部变量，互不影响</span></span><br><span class="line">    cout &lt;&lt; n;                <span class="comment">// 输出，验证结果</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(f, <span class="number">10</span>)</span></span>;           <span class="comment">// 启动两个线程，运行函数f</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(f, <span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>atomic变量禁用了拷贝构造函数，所以在初始化的时候不能用“&#x3D;”的赋值形式，只能用圆括号或者花括号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">atomic_int  x &#123;<span class="number">0</span>&#125;;          <span class="comment">// 初始化，不能用=</span></span><br><span class="line">atomic_long y &#123;<span class="number">1000L</span>&#125;;      <span class="comment">// 初始化，只能用圆括号或者花括号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(++x == <span class="number">1</span>);           <span class="comment">// 自增运算</span></span><br><span class="line"></span><br><span class="line">y += <span class="number">200</span>;                   <span class="comment">// 加法运算</span></span><br><span class="line"><span class="built_in">assert</span>(y &lt; <span class="number">2000</span>);           <span class="comment">// 比较运算</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> atomic_flag flag &#123;<span class="literal">false</span>&#125;;    <span class="comment">// 原子化的标志量</span></span><br><span class="line"><span class="type">static</span> atomic_int  n;               <span class="comment">// 原子化的int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]()              <span class="comment">// 在线程里运行的lambda表达式，捕获引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = flag.<span class="built_in">test_and_set</span>();  <span class="comment">// TAS检查原子标志量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;flag has been set.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set flag by &quot;</span> &lt;&lt;</span><br><span class="line">            this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;  <span class="comment">// 输出线程id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n += <span class="number">100</span>;                    <span class="comment">// 原子变量加法运算</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(      <span class="comment">// 线程睡眠</span></span><br><span class="line">        n.<span class="built_in">load</span>() * <span class="number">10</span>ms);        <span class="comment">// 使用时间字面量</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;;                        <span class="comment">// 在线程里运行的lambda表达式结束</span></span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(f)</span></span>;                <span class="comment">// 启动两个线程，运行函数f</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(f)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();                   <span class="comment">// 等待线程结束    </span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用std::async 启动一个线程去异步运行一个任务 但不绝对保证立即启动（也可以在第一个参数传递 std::launch::async，要求立即启动线程） 少显式用std::thread</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = [](<span class="keyword">auto</span> x)                  <span class="comment">// 在线程里运行的lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>( x * <span class="number">1</span>ms);  <span class="comment">// 线程睡眠</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sleep for &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">async</span>(task, <span class="number">10</span>);         <span class="comment">// 启动一个异步任务</span></span><br><span class="line">f.<span class="built_in">wait</span>();                              <span class="comment">// 等待任务完成</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(f.<span class="built_in">valid</span>());                    <span class="comment">// 确实已经完成了任务</span></span><br><span class="line">cout &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; endl;              <span class="comment">// 获取任务的执行结果</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>async() 会返回一个 future 变量，可以认为是代表了执行结果的 “期货”，如果任务有返回值，就可以用成员函数 get() 获取 <strong>不过要特别注意，get() 只能调一次，再次获取结果会发生错误，抛出异常 std::future_error</strong></p>
</li>
<li><p>如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以，即使我们不关心返回值，也总要用 auto 来配合 async()，避免同步阻塞</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">async</span>(task, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON解析库 JSON for Modern C++ (json.hpp, single header only)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">json_t</span> = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="type">json_t</span> j;                                   <span class="comment">// JSON对象</span></span><br><span class="line"></span><br><span class="line">j[<span class="string">&quot;age&quot;</span>] = <span class="number">23</span>;                              <span class="comment">// &quot;age&quot;:23</span></span><br><span class="line">j[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;spiderman&quot;</span>;                    <span class="comment">// &quot;name&quot;:&quot;spiderman&quot;</span></span><br><span class="line">j[<span class="string">&quot;gear&quot;</span>][<span class="string">&quot;suits&quot;</span>] = <span class="string">&quot;2099&quot;</span>;                <span class="comment">// &quot;gear&quot;:&#123;&quot;suits&quot;:&quot;2099&quot;&#125;</span></span><br><span class="line">j[<span class="string">&quot;jobs&quot;</span>] = &#123;<span class="string">&quot;superhero&quot;</span>&#125;;                  <span class="comment">// &quot;jobs&quot;:[&quot;superhero&quot;]  </span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;                   <span class="comment">// vector容器</span></span><br><span class="line">j[<span class="string">&quot;numbers&quot;</span>] = v;                          <span class="comment">// &quot;numbers&quot;:[1,2,3]</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m =                       <span class="comment">// map容器</span></span><br><span class="line">    &#123;&#123;<span class="string">&quot;one&quot;</span>,<span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;&#125;;               <span class="comment">// 初始化列表 </span></span><br><span class="line">j[<span class="string">&quot;kv&quot;</span>] = m;                               <span class="comment">// &quot;kv&quot;:&#123;&quot;one&quot;:1,&quot;two&quot;:2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; j.<span class="built_in">dump</span>() &lt;&lt; endl;         <span class="comment">// 序列化，无缩进</span></span><br><span class="line">cout &lt;&lt; j.<span class="built_in">dump</span>(<span class="number">2</span>) &lt;&lt; endl;        <span class="comment">// 序列化，有缩进，2个空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str = <span class="string">R&quot;(&#123;                // JSON文本，原始字符串</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;peter&quot;,</span></span><br><span class="line"><span class="string">    &quot;age&quot; : 23,</span></span><br><span class="line"><span class="string">    &quot;married&quot; : true</span></span><br><span class="line"><span class="string">&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> j = <span class="type">json_t</span>::<span class="built_in">parse</span>(str);    <span class="comment">// 从字符串反序列化</span></span><br><span class="line"><span class="built_in">assert</span>(j[<span class="string">&quot;age&quot;</span>] == <span class="number">23</span>);        <span class="comment">// 验证序列化是否正确</span></span><br><span class="line"><span class="built_in">assert</span>(j[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;peter&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> txt = <span class="string">&quot;bad:data&quot;</span>s;        <span class="comment">// 不是正确的JSON数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>                             <span class="comment">// try保护代码</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="type">json_t</span>::<span class="built_in">parse</span>(txt);<span class="comment">// 从字符串反序列化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::exception&amp; e)        <span class="comment">// 捕获异常</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h3><ul>
<li>libcurl</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(boostTester)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-Wall -O2 -pthread&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/json.hpp&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;json.hpp is missing, downloading...&quot;</span>)</span><br><span class="line">    <span class="keyword">file</span>(DOWNLOAD https://raw.githubusercontent.com/nlohmann/json/develop/single_include/nlohmann/json.hpp <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/json.hpp)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(CURL REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CURL_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;CURL_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_executable</span>(curlTester main.cpp)</span><br><span class="line"><span class="keyword">if</span>(CURL_FOUND)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(curlTester <span class="variable">$&#123;CURL_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send GET request</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="type">json_t</span> = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回掉写函数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">writeFunc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, std::string* data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> totalb = size * nmemb;</span><br><span class="line">    data-&gt;<span class="built_in">append</span>((<span class="type">char</span>*)ptr, totalb);</span><br><span class="line">    <span class="keyword">return</span> totalb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> handler = <span class="built_in">curl_easy_init</span>();    <span class="comment">// 创建CURL句柄</span></span><br><span class="line">    <span class="built_in">assert</span>(handler);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(handler, CURLOPT_URL, <span class="string">&quot;http://localhost:8080/api/v1/admin/merchant/all&quot;</span>); <span class="comment">// 设置请求URI</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(handler, CURLOPT_WRITEFUNCTION, writeFunc);</span><br><span class="line">    std::string resp;</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(handler, CURLOPT_WRITEDATA, &amp;resp);</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">curl_easy_perform</span>(handler); <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (res != CURLE_OK) &#123; <span class="comment">// 检查是否执行成功</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">curl_easy_strerror</span>(res) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="type">json_t</span>::<span class="built_in">parse</span>(resp);<span class="comment">// 从字符串反序列化</span></span><br><span class="line">        <span class="type">int</span> indent = <span class="number">4</span>;</span><br><span class="line">        cout &lt;&lt; j.<span class="built_in">dump</span>(indent);  <span class="comment">// pretty print</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">curl_easy_cleanup</span>(handler); <span class="comment">// 清理句柄相关的资源</span></span><br><span class="line">    <span class="built_in">curl_global_cleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python和C++相互通信: Pybind 11</p>
</li>
<li><p>设计原则 (SOLID)</p>
<ul>
<li><p>单一职责原则：一个类只负责一项工作，不允许有多个类同时负责一项工作。SRP (高内聚低耦合)</p>
</li>
<li><p>开闭原则：对扩展开放，对修改关闭。OCP (应用开闭原则的关键是做好封装，隐藏内部的具体实现细节，然后开放足够的接口，这样外部的客户代码就可以只通过接口去扩展功能，而不必侵入类的内部)</p>
</li>
<li><p>里氏替换原则：子类不应该替换父类。LSP (子类不能改变、违反父类定义的行为 C++里应少用继承 多用泛型)</p>
</li>
<li><p>接口隔离原则：把不同的接口分成不同的类，每个类只负责一个接口。ISP (尽量简化、归并给外界调用的接口)</p>
</li>
<li><p>依赖倒置原则：把抽象层的类和具体层的类分离开来，使得抽象层的类不依赖于具体层的类。DIP (上层要避免依赖下层的实现细节，下层要反过来依赖上层的抽象定义)</p>
</li>
<li><p>DRY原则 不造轮子</p>
</li>
<li><p>KISS原则</p>
</li>
</ul>
</li>
<li><p>C++中部分设计模式的实现</p>
<ul>
<li>单例模式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用函数内部的 static 静态变量</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> T obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>观察者模式的别名有信号机制或发布订阅机制 (qt信号槽)</p>
</li>
<li><p>new 和 delete 操作的区域是 free store</p>
</li>
<li><p>malloc 和 free 操作的区域是 heap</p>
</li>
<li><p>在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding)</p>
</li>
<li><p>通过往std命名空间特化hash的方式也可以实现custom hash</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;p)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(p.first) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(p.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; unset;</span><br></pre></td></tr></table></figure></article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/about"> About</a></li><li class="nav_item"><a class="nav-page" href="/blogs"> Blogs</a></li><li class="nav_item"><a class="nav-page" href="/projects"> Projects</a></li><li class="nav_item"><a class="nav-page" href="/notes"> Notes</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2023 by Haohu Shen</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script></body></html>